package controllers.apps;

import java.io.InputStream;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeMap;

import com.fasterxml.jackson.databind.JsonNode;

import actions.VisualizationCall;
import models.LargeRecord;
import models.MidataId;
import models.Plugin;
import models.Record;
import models.Space;
import play.mvc.BodyParser;
import play.mvc.Controller;
import play.mvc.Result;
import utils.access.RecordManager;
import utils.auth.RecordToken;
import utils.auth.SpaceToken;
import utils.collections.CMaps;
import utils.collections.ChainedMap;
import utils.collections.Sets;
import utils.db.FileStorage.FileData;
import utils.exceptions.AppException;
import utils.exceptions.BadRequestException;
import utils.json.JsonOutput;
import utils.json.JsonValidation;
import utils.json.JsonValidation.JsonValidationException;


//Not secured, accessible from app server
public class GenomeDataConverter extends Controller {

	private static final String dateTag = "generated by 23andMe at:";
	private static final String buildTag = "reference human assembly build";
	private static final String buildUrlTag = "# http://www.ncbi.nlm.nih.gov";

	@VisualizationCall
	public static Result checkPreflight() {				
		return ok();
	}

	/**
	 * Gets all the files of the user.
	 */
	@BodyParser.Of(BodyParser.Json.class)
	@VisualizationCall
	public static Result getFiles() throws AppException, JsonValidationException {
		
		// check whether the request is complete
		JsonNode json = request().body().asJson();		
		JsonValidation.validate(json, "authToken");
		
		// decrypt authToken
		SpaceToken appToken = SpaceToken.decryptAndSession(request(), json.get("authToken").asText());
		if (appToken == null) {
			return badRequest("Invalid authToken.");
		}

		// perform checks whether the auth token is valid and issued by the 23andMe Converter app
		String errorMessage = checkAuthToken(appToken);
		if (errorMessage != null) {
			return badRequest(errorMessage);
		}
		
		Set<String> fields = Sets.create("name");
		List<Record> records = RecordManager.instance.list(appToken.userId, appToken.userId, CMaps.map("format", "application/octet-stream"), fields);
		
		Collections.sort(records);
		return ok(JsonOutput.toJson(records, "Record", fields));
	}

	/**
	 * Check authenticity of request, i.e. whether it is performed by the 23andMe Converter app.
	 * @return An error message if a validity check failed, null otherwise.
	 */
	private static String checkAuthToken(SpaceToken appToken) throws AppException {
		
		
			Space space = Space.getByIdAndOwner(appToken.spaceId, appToken.userId, Sets.create("visualization"));
			if (space == null) throw new BadRequestException("error.invalid.token", "Invalid authToken.");
			
			// check whether the app is the 23andMe Converter app
			Map<String, Object> appProperties = new ChainedMap<String, Object>().put("_id", space.visualization)
					.put("filename", "23andme-converter").get();
			
			if (!Plugin.exists(appProperties)) {
				return "Invalid authToken.";
			}
		
		
		return null;
	}

	/**
	 * Convert a 23andMe file to the MIDATA format.
	 */
	@BodyParser.Of(BodyParser.Json.class)
	@VisualizationCall
	public static Result convert() throws JsonValidationException, AppException {
		
		// check whether the request is complete
		JsonNode json = request().body().asJson();		
		JsonValidation.validate(json, "authToken", "id", "name");
		

		// decrypt authToken
		SpaceToken appToken = SpaceToken.decryptAndSession(request(), json.get("authToken").asText());
		if (appToken == null) {
			throw new BadRequestException("error.invalid.token", "Invalid authToken.");
		}

		// perform checks whether the auth token is valid and issued by the 23andMe Converter app
		String errorMessage = checkAuthToken(appToken);
		if (errorMessage != null) {
			return badRequest(errorMessage);
		}
		
		Space space = Space.getByIdAndOwner(appToken.spaceId, appToken.userId, Sets.create("visualization"));
		
		//Member owner = Member.getByIdAndApp(appToken.userId, appToken.appId, Sets.create("myaps", "tokens"));
		//if (owner == null) return badRequest("Invalid authToken.");

		// parse the file
		FileData fileData = RecordManager.instance.fetchFile(appToken.userId, new RecordToken(JsonValidation.getMidataId(json, "id").toString(), appToken.userId.toString()));
		TreeMap<String, Object> map = new TreeMap<String, Object>();
		errorMessage = parseInput(fileData.inputStream, map);
		if (errorMessage != null) {
			return badRequest(errorMessage);
		}

		// create record
		Record record = new Record();
		record._id = new MidataId();
		record.app = space.visualization;
		record.created = new Date();
		record.creator = appToken.userId;
		record.owner = appToken.userId;
		record.name = JsonValidation.getString(json, "name");
		record.description = JsonValidation.getString(json, "description");
		record.content = "genome-data";
		record.format = "23-and-me"; //json.get("format").asText();
		record.data = null;
		
		LargeRecord.add(appToken.userId, record, map);
				
		return ok();
	}

	/**
	 * Parse the input stream and extract meta data and content.
	 */
	private static String parseInput(InputStream inputStream, TreeMap<String, Object> map) {
		try (Scanner scanner = new Scanner(inputStream)) {
			while (scanner.hasNextLine()) {
				String line = scanner.nextLine();
				if (line.startsWith("#")) {
					// this line is a comment; extract important information
					if (line.contains(dateTag)) {
						String date = line.split(dateTag, 2)[1].trim();
						map.put("date", date);
					} else if (line.contains(buildTag)) {
						int index = line.lastIndexOf(buildTag) + buildTag.length() + 1;
						String build = "";
						char character = line.charAt(index);
						while (Character.isDigit(character)) {
							build += character;
							character = line.charAt(++index);
						}
						map.put("build", build);
					} else if (line.startsWith(buildUrlTag)) {
						String buildUrl = line.substring(2).trim();
						map.put("buildUrl", buildUrl);
					}
				} else {
					// 23 and me files are tab-separated with exactly 4 columns
					String[] split = line.split("\t");
					if (split.length != 4) {
						// skip this line
						continue;
					} else {
						// the columns are (in order): rsid, chromosome, position, genotype
						String rsid = split[0]; // rs id or internal id (prefixed with 'i')
						String chromosome = split[1]; // can be 1-22, X, Y, MT
						int position = Integer.parseInt(split[2]); // position on the human reference genome
						String genotype = split[3]; // a pair of letters from A, C, G, T
						map.put(rsid, new Object[] { chromosome, position, genotype });
					}
				}
			}
		}

		// check whether data was found
		if (map.isEmpty()) {
			return "No data found. This is probably not a standard 23andMe file.";
		}
		return null;
	}

}
