	<!-- Content -->
	<div class="container" ng-controller="GuideCtrl">
		<div class="page-header">
			<h1>Developer's Guide</h1>
		</div>
		<div class="row">
			<div class="col-md-2">
				<ul class="nav nav-pills nav-stacked">
					<li ng-init="tab='home'" ng-class="{ 'active' : tab=='home' }"><a href="javascript:" ng-click="tab='home';">Home</a></li>
					<li ng-class="{ 'active' : tab=='accounts' }"><a href="javascript:" ng-click="tab='accounts';">Developer Accounts</a></li>
					<li ng-class="{ 'active' : tab=='architecture' }"><a href="javascript:" ng-click="tab='architecture';">Architecture</a></li>
					<li ng-class="{ 'active' : tab=='apps' }"><a href="javascript:" ng-click="tab='apps';">( Forms )</a></li>
					<li ng-class="{ 'active' : tab=='visualizations' }"><a href="javascript:" ng-click="tab='visualizations';">Plugins</a></li>
					<li ng-class="{ 'active' : tab=='mobile' }"><a href="javascript:" ng-click="tab='mobile';">Mobile Apps</a></li>
					<li ng-class="{ 'active' : tab=='formats' }"><a href="javascript:" ng-click="tab='formats';">Format List</a></li>
				</ul>
			</div>
			<div class="col-md-10">
				<div class="tab-content">
					<div id="home" class="tab-pane fade" ng-class="{ 'active in' : tab=='home' }">
						<h2>Overview</h2>
						<p>The developer's guide explains the general architecture of the
							platform, how plugins (forms and visualizations) interact with it, how
							mobile apps may connect with the MIDATA platform
							and how plugins and mobile apps bring in and display data.
						</p>
						<p><em style="font-weight:bold;">Forms</em> connect data sources to
							the platform. They are built to bring data onto the platform, by
							giving the users the possibility to either create a record
							themselves, or importing it from another where it has originally
							been created. Forms may connect to other domains to fetch data but are
							not allowed to read records from the platform.
						</p>
						<p><em style="font-weight:bold;">Visualizations</em> display an
							aggregated view of the records that are passed to them. The
							purpose of visualizations is to foster the users' understanding of
							their own data. Visualizations may read and write records from and to the
							MIDATA platform but they may not connect to external domains.
						</p>
						<p><em style="font-weight:bold;">Mobile Apps</em> may connect to the MIDATA platform
						    in behalf of a user and write records to the users account. It may also read records
						    but only those created by the app itself and those the user has granted access to.
						</p>
					</div>
					<div id="accounts" class="tab-pane fade" ng-class="{ 'active in' : tab=='accounts' }">
						<h2>Developer Accounts</h2>
						<p>If you want to develop a MIDATA plugin or mobile app you need a developer account.
						   Please click on "Sign Up" on the top of this page and create your account. Using the 
						   developer account you can register a new plugin or mobile app and manage it. 
						</p>
						<p>If you are developing a plugin you can test your development version running on your own computer 
						   using the developer portal. When you are done with development you need to send the code to us for review
						   and final integration.
						</p> 
					</div>
					<div id="architecture" class="tab-pane fade" ng-class="{ 'active in' : tab=='architecture' }">
						<h2>Architecture</h2>
						<p>The platform promises not to give data out. To adhere to that 
							promise, plugins run on an isolated and sandboxed application 
							server, that can only connect to the web application server, and 
							therefore especially not to the internet.</p>
						<p>Plugins may be registered via your developer account but the final code version needs to be
						   deployed by us on the plugin server.</p>
					</div>
					<div id="apps" class="tab-pane fade" ng-class="{ 'active in' : tab=='apps' }">
						<h2>Forms / Importers</h2>
						<p>A form or import form provides the functionality to create or import  
						records. This type of plugin may access external resources but may not read records from the platform.</p>
						<p>The API and API documentation for forms will be updated soon</p>
					</div>
					<div id="visualizations" class="tab-pane fade" ng-class="{ 'active in' : tab=='visualizations' }">
						<h2>Plugins</h2>
						<p>Plugins run in the browser and have read and write access to a set of records. The set of records
						available may be changed by the user. The application developer can propose a query that - if accepted by the user - 
						determines the initially available set of records.
						</p>
					    <h3>Registration using the developer account</h3>					
						<p>Each plugin needs to have an internal name that is used by the platform to identify that app.
						The plugin developer also needs to specify a public name for the marked place and a textual description, that describe
						what it does. This is shown to the user and 
						should capture the purpose and capabilities of the visualization best. </p>
						<p>To register your plugin, log in into your developer account. On the "Your Plugins" page click on "Register a new plugin" and fill out the form.
						   Choose "Visualization" as "type" of the plugin. 						   
						   Click on "Submit" when you are done.
						</p>
												
						<h4>URL</h4>
						<p>The third property that has to be specified is the URL that will be 
						called with the records selected to be displayed by the app. The URL is 
						relative to the visualization's base directory and can be chosen 
						arbitrarily. It only has to include a part that contains the string
						<code>:authToken</code>. This part will be replaced with an authentication token that needs
						to be passed to the server with every API request.</p>
						<p>So if the main file in located in a 'dist' subdirectory and is called index.html your URL may look like this:</p>
						<pre>dist/index.html#:authToken</pre>
						<h3>Creating new Records</h3>
						<p class="alert alert-info">Please note that the API runs at <strong>{{ENV.apiurl}}</strong></p>
						<p>The Endpoint is at:</p>
						<pre><i>POST</i> /v1/plugin_api/records/create</pre>
						<p>For a detailed description of the parameters see <a ng-click="tab='mobile'">Mobile API</a>.</p>
						<h3>Retrieving existing records</h3>
						<p>The Endpoint is at:</p>
						<pre><i>POST</i> /v1/plugin_api/records/search</pre>
						<p>For a detailed description of the parameters see <a ng-click="tab='mobile'">Mobile API</a>.</p>
						<h3>Writing a configuration object</h3>
						<p>Each plugin may store a configuration JSON on the server. This piece of information may only be read by the plugin itself and is updateable.
						To store a configuration call:
						</p>
						<pre><i>POST</i> /v1/plugins_api/config/set</pre>
						<p>Pass these parameters as JSON body:</p>
<pre>{
  "authToken" : The authentication token you got
  "config" : A JSON object you want to store as your configration
}</pre>
                        <p>You will receive an empty status 200 response.</p>
						<h3>Reading your configuration object</h3>
						<p>To read a configutation object previously stored, call:</p>
						<pre><i>POST</i> /v1/plugins_api/config/get</pre>
						<p>with this JSON body:</p>
<pre>{
  "authToken" : The authentication token you got
}</pre>						
                        <p>As response you will receive your configuration JSON back. If no configuration
                        has been stored you will receive an empty status 200 response.</p>						
						<h3>Cloning your plugin with a different configuration</h3>
						<p>Your plugin may clone itself with a different configuration and dashboard tile title. To do this call:
						<pre><i>POST</i> /v1/plugins_api/clone</pre>
						<p>Use these parameters as JSON body:</p>
<pre>{
  "authToken" : The authentication token you got
  "name" : A title for the new dashboard tile
  "config" : A JSON object you want to store as configration for the new plugin instance
}</pre>						
						
					</div>
					<div id="mobile" class="tab-pane fade" ng-class="{ 'active in' : tab=='mobile' }">
						<h2>Mobile Apps</h2>
						<p>Mobile Apps are external applications that provide and/or query records from the platform.</p>
						<h3>Registration using the developer account</h3>					
						<p>Each app needs to have an internal name that is used by the platform to identify that app.
						The app developer also needs to specify a public name for the marked place and a textual description, that describe
						what it does. Also a secret key needs to be entered that is known to the mobile app but should not be made public.</p>
						<p>To register your app, log in into your developer account. On the "Your Plugins" page click on "Register a new plugin" and fill out the form.
						   Choose "Mobile App" as "type" of the plugin. 
						   <i>In the current release do not select "Spotlight in Market". (will be removed)</i>
						   Click on "Submit" when you are done.
						</p>		
						<p class="alert alert-info">Please note that the API runs at <strong>{{ENV.apiurl}}</strong></p>										
                        <h3>Authentication (Login)</h3>						
						<p>A mobile app needs to authenticate using a users credentials to the platform before providing or querying records.
						To authenticate call:</p> 
						<pre><i>POST</i> /v1/auth</pre>
						<p>with these parameters as JSON body:</p>
<pre>{ 
      "appname" : internal name of the application,
      "secret" : the secret key that has been chosen on the development portal  
      "username" : the email of the user, 
      "password" : password of user 
}</pre>						
					    <p>As result you either get a 400 status with an error message or a session tokens that can be used for further requests.</p>
						<p>An example response looks like this:</p>
<pre>{
      "authToken":"014760...",
      "refreshToken":"6756756756...."
}</pre>
                        <p>After the first login of a user using the mobile app a new "<b>consent</b>" is automatically created in the users MIDATA account.
                           This consent may be used by the user to select which data he/she wants to share with your mobile app.
                           As long as this consent has not been accepted by the member it does not share any data so that your app will see a blank account. The app is not allowed to create
                           records until the consent is confirmed.
                        </p>  
                        <p>The "<code>password</code>" may be choosen freely during the first login. It does not need to be the same password as for the portal.
                           For all subsequent logins the same password must be used. If the password is lost the user may log into the portal and delete the consent to freely choose a new password.
                           A password recovery function for apps will be integrated into the portal.                            
                        </p>
                        <p>The "<code>authToken</code>" needs to be passed to all other API functions for authentication. The "<code>refreshToken</code>" may be used to skip the login process the next time.
                        To reauthenticate issue this request:</p>
                        <pre><i>POST</i> /v1/auth</pre>
						<p>with these parameters as JSON body:</p>
<pre>{ 
      "appname" : internal name of the application,
      "secret" : the secret key that has been chosen on the development portal  
      "refreshToken" : the refresh token from last login 	  
}</pre>                
                        <p>The result is the same as for the initial login. Please note that a new refreshToken will be returned every call to /v1/auth and only the last returned token is valid.
                           Previously returned refreshTokens are invalidated.                           
                        </p>   
                        <p>API calls will return a status code of <code>401</code> if a relogin is required.</p>
                                              
						<h3>Creating new records</h3>
						<p>To create a new record call this endpoint:</p>
						<pre><i>POST</i> /v1/records/create</pre>
						<p>The request needs a JSON body with these parameters:</p>
<pre>{
     "authToken" : the token from the authentication request, 
     "name" : a name for the record, 
     "description" : a description for the record,
     "format" : a string describing the technical data format,
     "content" : a string describing the data content
     "data" : JSON string containing the record itself 
}</pre>						

						<h3>Updating an existing record</h3>
						<p>In order to update an existing record call this endpoint:</p>
						<pre><i>POST</i> /v1/records/update</pre>
						<p>The request needs a JSON body with these parameters:</p>
<pre>{
     "authToken" : the token from the authentication request, 
     "_id" : the identifier of the record you want to change, 
     "version" : the version field of the record that you have read before     
     "data" : JSON string containing the new content of the record itself 
}</pre>						
                        <p>To update a record you first need to read it, so that you know the <code>_id</code> and <code>version</code> of the particular record. 
                           During the update a new version is assigned to the record. The update operation will fail with a HTTP status code of <code>409</code>(Conflict) if the records version field does not match the version field stored in the database. 
                           So the call will fail if the record has been modified by another API call since your last read.
                        </p>
                        <p>Only the data of a record may be changed. The other fields as format or name are immutable.</p> 
                        <p>After a successful update the new version string will be returned together with HTTP status <code>200</code>:</p>
<pre>{
     "version" : "12345"
}</pre>                        

                        <h3>Retrieving existing records</h3>
                        <p>To retrieve records call this endpoint:</p>
                        <pre><i>POST</i> /v1/records/search</pre>
                        <p>The request needs a JSON body with these parameters:</p>
<pre>{
     "authToken": the token from the authentication request,
     "fields" : a string array of field names to return,
     "properties" : a key-value map with restrictions. (May be empty) 
}</pre>           
<p>Possible values for <code>fields</code> are:
  <ul>  
    <li><code>_id</code> - the internal id of the record</li>    
    <li><code>owner</code> - the id of the owner of the record (or null if not public)</li>
    <li><code>ownerName</code> - the owner of the record as string (firstname lastname)</li>
    <li><code>creator</code> - the id of the creator of the record (or null if not public)</li>
    <li><code>creatorName</code> - the creator of the record as string (firstname lastname)</li>
    <li><code>format</code> - the technical format of the record</li>
    <li><code>content</code> - the semantical format of the record</li>
    <li><code>group</code> - the name of the group where this record is listed in the data tree</li>
    <li><code>app</code> - the id of the app that created this record</li>
    <li><code>created</code> - the date of creation of this record</li>
    <li><code>name</code> - the name of this record</li>
    <li><code>description</code> - the description of this record</li>
    <li><code>tags</code> - an array of tags for this record</li>
    <li><code>version</code> - a string identifying the current version of this record</li>
    <li><code>data</code> - the data of this record as string or json</li>
 </ul>
<p>Each key in the properties map restricts the returned records by one criteria.</p>
<p>Each values in the properties map may be either a single value or an array of multiple values.
In the array case each record must match one entry in the array to qualify for the query.</p>
<p>Possible keys for <code>properties</code> are: (only those listed that are currently supported)
  <ul>  
    <li><code>_id</code> - (id) restrict by id of the record</li>
    <!--     
    <li><code>owner</code> - (id/string) restrict by owner id of the record. The following special string values are allowed as value for this restriction:
       <ul>
         <li><code>self</code> - only records from the account owner</li>
         <li><code>other</code> - only records not from the account owner</li>
         <li><code>shared</code> - only records from the account owner that have been shared</li>         
       </ul>
    </li>       
     -->
    <li><code>format</code> - (string) the technical format of the record</li>
    <li><code>content</code> - (string) the semantical format of the record</li>
    <li><code>group</code> - (string) the group of the record may be one of the given groups or a child of those.</li>
    <li><code>group-strict</code> - (string) the group of the record must be one of the given groups.</li>
    <li><code>group-exclude</code> - (string) the group of the record must NOT be one of the given groups or a child of those.</li>    
    <li><code>created-after</code> - (date) only records created after the given date/time</li>
    <li><code>created-before</code> - (date) only records created earlier than the given date/time</li>
    <li><code>max-age</code> - (integer) only records not older than the given amount of seconds</li>
    <li><code>creator</code> - (id) only records with a specific creator</li>
    <li><code>limit</code> - (integer) the maximum count of records you want to receive</li>    
 </ul>
 <p>The response to the query is an array of records having only the fields you requested.</p>  
   

















<h3>Summary Query</h3>
  <p>If the app needs an overview about how many records are there, what formats or groups they belong to and/or how old
     they are a summary query may help. Please note that on larger data sets a summary query will be executed much faster than
     a regular query.</p>
  <p>For a summary query call this endpoint:</p>
  <pre><i>POST</i> /v1/records/summary</pre>
                        <p>The request needs a JSON body with these parameters:</p>
<pre>{
     "authToken": the token from the authentication request,
     "summarize" : the level of grouping required,
     "properties" : a key-value map with restrictions. (May be empty) 
}</pre>           
<p>Possible values for <code>summarize</code> parameter are:
  <ul>  
    <li><code>ALL</code> - returns one entry summarizing everything</li>    
    <li><code>GROUP</code> - returns one entry for each group</li>
    <li><code>FORMAT</code> - returns one entry for each format used</li>
    <li><code>CONTENT</code> - returns one entry for each content (type) used</li>
    <li><code>SINGLE</code> - returns one entry for each different type of record</li>    
 </ul>
<p>Each key in the properties map restricts the returned records by one criteria.</p>
<p>Each values in the properties map may be either a single value or an array of multiple values.
In the array case each record must match one entry in the array to qualify for the query.</p>
<p>Possible keys for <code>properties</code> are: (only those listed that are currently supported)
  <ul>      
    <li><code>format</code> - (string) the technical format of the record</li>
    <li><code>content</code> - (string) the semantical format of the record</li>
    <li><code>group</code> - (string) the group of the record may be one of the given groups or a child of those.</li>       
 </ul>
 <p>The response to the query is an array of information objects looking like that:</p>  
<pre>
 [
   {
      "count" : 10000,
      "oldest" : 1442491494782,
      "newest" : 1442491882705,
      "calculated" : 1447336206527,
      "formats" : ["measurements"],
      "contents" : ["food/water"],
      "groups" : ["nutrition"],
      "newestRecord" : {"$oid":"55faadeae4b0b22590969f44"}
   },
   {
      "count" : 101,
      "oldest" : 1442491223087,
      "newest" : 1442491287684,
      "calculated" : 1447336206862,
      "formats" : ["measurements"],
      "contents" : ["activities/fairly-active","activities/more-active"],
      "groups": ["movement"],
      "newestRecord" : {"$oid":"55faab97e4b0b2259096744a"}
   }
 ]
</pre>                                  
<p>The grouping of records into summary objects depend on the "summarize" parameter. In the example they are summarized by "GROUP". 
   The meaning of the fields are:</p>
<ul>
  <li><code>count</code> The number of records</li>
  <li><code>oldest</code> timestamp of the oldest record</li>
  <li><code>newest</code> timestamp of the newest record</li>
  <li><code>calculated</code> calculation timestamp (internally used)</li>
  <li><code>formats</code> list of different formats of the records summarized in this entry</li>
  <li><code>contents</code> list of different contents of the records summarized in this entry</li>
  <li><code>groups</code> list of different groups of the records summarized in this entry</li>
  <li><code>newestRecord</code> _id of newest record in this group. May be used to fetch it in a separate search query</li> 
</ul>   
   
   
   
   
   
   
                                   
					</div>
					<div id="formats" class="tab-pane fade" ng-class="{ 'active in' : tab=='formats' }">
						<h2>List of data formats</h2>
						<p>The list of supported data formats is directly queried from the server and may be extended any time.</p>
						<h3>Format</h3>
						<p>These technical data formats are currently recognized by the server. The list contains development artifacts and may be cleaned up in the future.</p>
						<ul>
						  <li ng-repeat="format in formats">
						    <code>{{ format.format }}</code>
						  </li>
						</ul>
						<h3>Content</h3>
						<p>All semantical data types start with one of the following prefixes and a more detailed name after the slash. The prefix is used to place the record into a group. 
						   The assignment of content types to groups may be changed in the future.</p>
						<p> An example full content name (from Fitbit) is <code>activities/fairly-active</code>
						    with format <code>measurements</code>. 
						</p> 
						<table width="100%">						 
						  <tr>
						    <th>Prefix</th>
						    <th>Placed in group</th>
						    <th>Level of security applied</th>
						  </tr>
						  <tr ng-repeat="content in contents">
						    <td><code>{{ content.content }}/...</code></td>
						    <td>{{ content.group }}</td>
						    <td>{{ content.security }}</td>
						  </tr>
						</table>
					</div>
					
				</div>
			</div>
		</div>
	</div>
